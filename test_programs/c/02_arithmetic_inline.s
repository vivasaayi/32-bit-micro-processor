; Generated by Simple C Compiler
; Custom RISC Assembly Output

    ; Runtime support functions
malloc:
    ; Simple malloc - returns fixed heap addresses
    load r1, heap_ptr
    add r2, r1, r0
    store r2, heap_ptr
    mov r0, r1
    ret

putchar:
    ; Output character in r0
    out r0
    ret

strlen:
    ; String length - string pointer in r0
    mov r1, r0
    mov r0, #0
strlen_loop:
    load r2, [r1]
    cmp r2, #0
    je strlen_end
    add r0, r0, #1
    add r1, r1, #1
    jmp strlen_loop
strlen_end:
    ret

; Data section
heap_ptr: .word 0x10000

    ; Compound statement
    ; Function declaration
main:
    push fp
    mov fp, sp
    sub sp, sp, #64
    ; Compound statement
    ; Variable declaration
; Variable a allocated at [fp-4]
    mov r1, #10
    ; Store initializer value for a
    store r1, [fp-4]
    ; Variable declaration
; Variable b allocated at [fp-8]
    mov r1, #3
    ; Store initializer value for b
    store r1, [fp-8]
    ; Variable declaration
; Variable result allocated at [fp-12]
    ; Function call
    lea r3, str0
    jmp str0_end
str0: .string "=== Arithmetic Test ===
"
str0_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    load r1, [fp-4]
    load r2, [fp-8]
    add r1, r1, r2
    ; Store to variable result
    store r1, [fp-12]
    mov r0, r1
    ; Function call
    lea r3, str1
    jmp str1_end
str1: .string "10 + 3 = "
str1_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    ; If statement
    load r1, [fp-12]
    mov r2, #13
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L2
    ; Compound statement
    ; Function call
    lea r3, str4
    jmp str4_end
str4: .string "13"
str4_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L3
L2:
    ; If statement
    load r1, [fp-12]
    mov r2, #0
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L5
    ; Compound statement
    ; Function call
    lea r3, str7
    jmp str7_end
str7: .string "0"
str7_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L6
L5:
    ; Compound statement
    ; Function call
    lea r3, str8
    jmp str8_end
str8: .string "?"
str8_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
L6:
L3:
    ; Function call
    lea r3, str9
    jmp str9_end
str9: .string "
"
str9_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    load r1, [fp-4]
    load r2, [fp-8]
    sub r1, r1, r2
    ; Store to variable result
    store r1, [fp-12]
    mov r0, r1
    ; Function call
    lea r3, str10
    jmp str10_end
str10: .string "10 - 3 = "
str10_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    ; If statement
    load r1, [fp-12]
    mov r2, #7
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L11
    ; Compound statement
    ; Function call
    lea r3, str13
    jmp str13_end
str13: .string "7"
str13_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L12
L11:
    ; If statement
    load r1, [fp-12]
    mov r2, #0
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L14
    ; Compound statement
    ; Function call
    lea r3, str16
    jmp str16_end
str16: .string "0"
str16_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L15
L14:
    ; Compound statement
    ; Function call
    lea r3, str17
    jmp str17_end
str17: .string "?"
str17_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
L15:
L12:
    ; Function call
    lea r3, str18
    jmp str18_end
str18: .string "
"
str18_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    load r1, [fp-4]
    load r2, [fp-8]
    mul r1, r1, r2
    ; Store to variable result
    store r1, [fp-12]
    mov r0, r1
    ; Function call
    lea r3, str19
    jmp str19_end
str19: .string "10 * 3 = "
str19_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    ; If statement
    load r1, [fp-12]
    mov r2, #30
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L20
    ; Compound statement
    ; Function call
    lea r3, str22
    jmp str22_end
str22: .string "30"
str22_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L21
L20:
    ; If statement
    load r1, [fp-12]
    mov r2, #0
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L23
    ; Compound statement
    ; Function call
    lea r3, str25
    jmp str25_end
str25: .string "0"
str25_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L24
L23:
    ; Compound statement
    ; Function call
    lea r3, str26
    jmp str26_end
str26: .string "?"
str26_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
L24:
L21:
    ; Function call
    lea r3, str27
    jmp str27_end
str27: .string "
"
str27_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    load r1, [fp-4]
    load r2, [fp-8]
    div r1, r1, r2
    ; Store to variable result
    store r1, [fp-12]
    mov r0, r1
    ; Function call
    lea r3, str28
    jmp str28_end
str28: .string "10 / 3 = "
str28_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    ; If statement
    load r1, [fp-12]
    mov r2, #3
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L29
    ; Compound statement
    ; Function call
    lea r3, str31
    jmp str31_end
str31: .string "3"
str31_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L30
L29:
    ; If statement
    load r1, [fp-12]
    mov r2, #0
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L32
    ; Compound statement
    ; Function call
    lea r3, str34
    jmp str34_end
str34: .string "0"
str34_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L33
L32:
    ; Compound statement
    ; Function call
    lea r3, str35
    jmp str35_end
str35: .string "?"
str35_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
L33:
L30:
    ; Function call
    lea r3, str36
    jmp str36_end
str36: .string "
"
str36_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    load r1, [fp-4]
    load r2, [fp-8]
    mod r1, r1, r2
    ; Store to variable result
    store r1, [fp-12]
    mov r0, r1
    ; Function call
    lea r3, str37
    jmp str37_end
str37: .string "10 % 3 = "
str37_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    ; If statement
    load r1, [fp-12]
    mov r2, #1
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L38
    ; Compound statement
    ; Function call
    lea r3, str40
    jmp str40_end
str40: .string "1"
str40_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L39
L38:
    ; If statement
    load r1, [fp-12]
    mov r2, #0
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L41
    ; Compound statement
    ; Function call
    lea r3, str43
    jmp str43_end
str43: .string "0"
str43_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L42
L41:
    ; Compound statement
    ; Function call
    lea r3, str44
    jmp str44_end
str44: .string "?"
str44_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
L42:
L39:
    ; Function call
    lea r3, str45
    jmp str45_end
str45: .string "
"
str45_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    ; Function call
    lea r3, str46
    jmp str46_end
str46: .string "All operations completed
"
str46_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    ; If statement
    load r1, [fp-12]
    mov r2, #1
    cmp r1, r2
    seteq r0
    cmp r0, #0
    je L47
    ; Compound statement
    ; Function call
    lea r3, str49
    jmp str49_end
str49: .string "SUCCESS: Final modulo result is 1 as expected
"
str49_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
    jmp L48
L47:
    ; Compound statement
    ; Function call
    lea r3, str50
    jmp str50_end
str50: .string "ERROR: Unexpected modulo result
"
str50_end:
    push r3
    call log_string
    add sp, sp, #4
    mov r0, r0
L48:
    ; Return statement
    load r0, [fp-12]
    add sp, sp, #64
    pop fp
    ret 
main_end:
    add sp, sp, #64
    pop fp
    ret 


; Program entry point
_start:
    call main
    halt
