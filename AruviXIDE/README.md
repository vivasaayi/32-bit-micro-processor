# RISC Processor Java UI Integration

This directory contains a complete Java-based UI system for visualizing framebuffer output from your RISC processor simulation in real-time.

## Overview

The system consists of:

1. **Java UI Viewer** - A Swing application that displays framebuffer images
2. **Verilog Framebuffer Dumper** - Hardware module that exports framebuffer to files
3. **Display Buffer** - Memory-mapped framebuffer for the CPU to write to
4. **Integration Scripts** - Automation for building and running the complete system

## Files

### Java UI Components
- `SimpleFramebufferViewer.java` - Basic viewer with manual/auto refresh
- `FramebufferViewer.java` - Advanced viewer with file watching and controls
- `config.properties` - Configuration file for display settings

### Verilog Components
- `processor/io/framebuffer_dumper.v` - Module that dumps framebuffer to PPM files
- Enhanced testbenches with framebuffer support

### Scripts
- `build_java_ui.sh` - Build and run the Java viewer
- `run_java_ui_demo.sh` - Complete integration demo

## Quick Start

### 1. Build and Test Java UI

```bash
# Build and run the simple viewer
cd java_ui
javac SimpleFramebufferViewer.java
java SimpleFramebufferViewer
```

### 2. Run Complete Demo

```bash
# Run the full integration demo
./run_java_ui_demo.sh
```

This will:
- Compile the Java UI
- Start the framebuffer viewer
- Generate sample framebuffer files
- Show real-time updates in the Java window

### 3. Integration with Your Processor

To integrate with your existing RISC processor:

1. Add the framebuffer dumper module to your system:
```verilog
framebuffer_dumper #(
    .FRAME_WIDTH(320), 
    .FRAME_HEIGHT(240), 
    .DUMP_INTERVAL(100000)
) dumper (
    .clk(clk), .rst_n(rst_n), 
    .enable(1'b1),
    .fb_addr(fb_addr), 
    .fb_data(fb_data),
    .fb_read(fb_read), 
    .fb_ready(fb_ready),
    .framebuffer_base_addr(32'h10000), 
    .dump_complete()
);
```

2. Add display buffer for CPU access:
```verilog
display_buffer #(
    .FRAME_WIDTH(320), 
    .FRAME_HEIGHT(240), 
    .BASE_ADDR(32'h10000)
) display (
    .clk(clk), .rst_n(rst_n),
    .cpu_addr(addr_bus), 
    .cpu_data(data_bus),
    .cpu_read(mem_read), 
    .cpu_write(mem_write),
    .fb_addr(fb_addr), 
    .fb_data(fb_data),
    .fb_read(fb_read), 
    .fb_ready(fb_ready)
);
```

3. Write assembly programs that draw to framebuffer:
```assembly
# Example: Fill screen with red
LOADI R1, 65536      # Framebuffer base (0x10000)
LOADI R2, 0xFF0000   # Red color
LOADI R3, 76800      # Total pixels (320*240)

loop:
    STORE R2, R1       # Write pixel
    ADDI R1, R1, 4     # Next pixel address
    SUBI R3, R3, 1     # Decrement counter
    JNZ loop           # Continue if not zero
```

## Display Format

The framebuffer uses:
- **Resolution**: 320x240 pixels (configurable)
- **Format**: 32-bit RGBA (0xRRGGBBAA)
- **Memory Layout**: Linear, 4 bytes per pixel
- **Base Address**: 0x10000 (configurable)

## File Formats Supported

The Java UI supports multiple image formats:
- **PPM (P6)** - Primary format generated by Verilog
- **BMP, PNG, JPEG** - Standard formats via ImageIO
- **Raw binary** - Direct framebuffer dumps

## Configuration

Edit `java_ui/config.properties` to customize:
```properties
framebuffer.path=temp/reports/framebuffer.ppm
display.width=320
display.height=240
refresh.rate=500
```

## Advanced Features

### Real-time File Watching
The advanced viewer automatically detects file changes and updates the display.

### Frame Saving
Click "Save Frame" to export the current display as PNG.

### Multiple Refresh Modes
- Manual refresh (click button)
- Timer-based auto refresh
- File system watching

### Status Information
- Frame counter
- Image dimensions
- File size
- Timestamp

## Integration Examples

### Example 1: Simple Graphics Test
```c
// C code compiled to assembly
void draw_gradient() {
    uint32_t *fb = (uint32_t *)0x10000;
    for (int y = 0; y < 240; y++) {
        for (int x = 0; x < 320; x++) {
            uint8_t r = (x * 255) / 320;
            uint8_t g = (y * 255) / 240;
            uint8_t b = 128;
            fb[y * 320 + x] = (r << 24) | (g << 16) | (b << 8) | 0xFF;
        }
    }
}
```

### Example 2: Animation Loop
```assembly
# Animated color cycling
main:
    LOADI R1, 65536    # Framebuffer base
    LOADI R2, 0        # Color counter
    
animate_loop:
    CALL fill_screen   # Fill with current color
    ADDI R2, R2, 1000  # Change color
    JMP animate_loop   # Repeat

fill_screen:
    # Fill screen with color in R2
    # Implementation here...
    RET
```

## Troubleshooting

### Java UI Not Starting
- Check Java installation: `java -version`
- Ensure Java Swing is available (included in standard JDK)
- Check file permissions on the java_ui directory

### No Image Display
- Verify framebuffer file exists: `ls -la temp/reports/`
- Check file format (should be PPM P6)
- Ensure file is not empty or corrupted

### Simulation Issues
- Verify Icarus Verilog installation: `iverilog -V`
- Check Verilog file paths in testbench
- Ensure memory addresses match between hardware and software

## Performance Notes

- File dumps occur every DUMP_INTERVAL clock cycles (configurable)
- Large framebuffers may slow simulation
- Java UI refresh rate is independent of simulation speed
- Use VCD files for detailed timing analysis

## Extension Ideas

1. **Audio Visualization** - Add waveform display for audio output
2. **Register Viewer** - Real-time CPU register display
3. **Memory Browser** - Interactive memory inspection
4. **Performance Metrics** - FPS, memory bandwidth monitoring
5. **Remote Connection** - TCP/IP interface for external tools

This implementation provides a solid foundation for visual debugging and demonstration of your RISC processor's graphics capabilities.
