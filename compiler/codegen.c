/*
 * Code Generator Implementation
 * Emits custom RISC assembly from AST
 */

#include "codegen.h"
#include <stdarg.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Main code generation function
int generate_code(AstNode *ast, SymbolTable *symbols, FILE *output) {
  if (!ast || !symbols || !output)
    return 0;

  CodegenContext ctx = {.output = output,
                        .symbols = symbols,
                        .label_counter = 0,
                        .temp_counter = 0,
                        .current_function_offset = 0,
                        .break_label = -1,
                        .continue_label = -1,
                        .local_vars = NULL,
                        .stack_offset = 0};

  // Emit assembly header
  fprintf(output, "; Generated by Simple C Compiler\n");
  fprintf(output, "; Custom RISC Assembly Output\n\n");

  // Emit program entry point
  fprintf(output, ".org 0x8000\n");
  fprintf(output, "_start:\n");
  fprintf(output, "    li sp, 0x000F0000\n"); // High address for stack
  fprintf(output, "    call main\n");
  fprintf(output, "    li a0, 0\n");
  fprintf(output, "    halt\n\n");

  // Emit runtime functions
  emit_runtime_functions(&ctx);

  // Generate code for the entire program
  codegen_node(ast, &ctx);

  return 1;
}

// Generate code for any AST node
void codegen_node(AstNode *node, CodegenContext *ctx) {
  if (!node)
    return;

  switch (node->type) {
  case AST_COMPOUND_STMT:
    emit_comment(ctx, "Compound statement");
    for (int i = 0; i < node->child_count; i++) {
      codegen_node(node->children[i], ctx);
    }
    break;

  case AST_FUNCTION_DECL:
  case AST_VARIABLE_DECL:
  case AST_STRUCT_DECL:
  case AST_ENUM_DECL:
  case AST_TYPEDEF_DECL:
    codegen_declaration(node, ctx);
    break;

  case AST_IF_STMT:
  case AST_WHILE_STMT:
  case AST_FOR_STMT:
  case AST_RETURN_STMT:
  case AST_BREAK_STMT:
  case AST_CONTINUE_STMT:
  case AST_EXPRESSION_STMT:
    codegen_statement(node, ctx);
    break;

  default:
    // For expressions and other nodes, generate into temp register
    codegen_expression(node, ctx, "r0");
    break;
  }
}

// Generate code for declarations
void codegen_declaration(AstNode *decl, CodegenContext *ctx) {
  if (!decl)
    return;

  switch (decl->type) {
  case AST_FUNCTION_DECL:
    codegen_function_decl(decl, ctx);
    break;

  case AST_VARIABLE_DECL:
    codegen_variable_decl(decl, ctx);
    break;

  case AST_STRUCT_DECL:
  case AST_ENUM_DECL:
  case AST_TYPEDEF_DECL:
    // These don't generate runtime code, just type information
    emit_comment(ctx, "Type declaration (no runtime code)");
    break;

  default:
    break;
  }
}

// Generate code for function declaration
void codegen_function_decl(AstNode *func, CodegenContext *ctx) {
  const char *name = func->data.function_decl.name;

  // Clear any previous local variables
  clear_local_variables(ctx);
  ctx->stack_offset = -8; // Account for saved ra and s0

  emit_comment(ctx, "Function declaration");
  fprintf(ctx->output, "%s:\n", name);

  // Function prologue
  // Standard Risc-V: sp grows down. Save ra, s0(fp).
  emit_instruction(ctx, "addi", "sp, sp, -16");
  emit_instruction(ctx, "sw", "ra, 12(sp)");
  emit_instruction(ctx, "sw", "s0, 8(sp)");
  emit_instruction(ctx, "addi", "s0, sp, 16");

  // Allocate space for local variables (will be calculated as we go)
  emit_instruction(ctx, "addi", "sp, sp, -256");

  // Register parameters from the parameter list if present
  if (func->child_count > 0 && func->children[0] &&
      func->children[0]->type == AST_PARAMETER_LIST) {
    AstNode *params = func->children[0];
    for (int i = 0; i < params->child_count; i++) {
      AstNode *param = params->children[i];
      if (param->type == AST_PARAMETER) {
        // Parameters are pushed by caller, so they are at positive offsets from
        // s0 arg1 is pushed first, so it has higher address. For n params:
        // arg_i is at (n - 1 - i) * 4
        int offset = (params->child_count - 1 - i) * 4;
        VariableLocation *var = malloc(sizeof(VariableLocation));
        var->name = strdup(param->data.parameter.name);
        var->stack_offset = offset;
        var->next = ctx->local_vars;
        ctx->local_vars = var;
        fprintf(ctx->output, "    ; Parameter %s at offset %d\n", var->name,
                offset);
      }
    }
  }

  // Generate function body
  if (func->child_count > 1 && func->children[1]) {
    ctx->current_function_offset = 0;
    codegen_node(func->children[1], ctx);
  }

  // Function epilogue (if no explicit return)
  fprintf(ctx->output, "%s_end:\n", name);
  emit_instruction(ctx, "addi", "sp, sp, 256");
  emit_instruction(ctx, "lw", "s0, 8(sp)");
  emit_instruction(ctx, "lw", "ra, 12(sp)");
  emit_instruction(ctx, "addi", "sp, sp, 16");
  emit_instruction(ctx, "ret", "");
  fprintf(ctx->output, "\n");
}

// Generate code for variable declaration
void codegen_variable_decl(AstNode *var, CodegenContext *ctx) {
  const char *name = var->data.variable_decl.name;
  Type *type = var->data.variable_decl.type;

  emit_comment(ctx, "Variable declaration");

  // Check if it's an array type
  if (type && type->base_type == TYPE_ARRAY) {
    int array_size = type->array_size;
    int element_size = 4;
    if (type->element_type && type->element_type->base_type == TYPE_CHAR) {
      element_size = 1;
    }
    int total_size = array_size * element_size;

    fprintf(ctx->output, "; Array %s[%d] allocated (%d bytes)\n", name,
            array_size, total_size);

    // Add to local variables with proper stack offset
    add_local_variable(ctx, name, total_size);
  } else {
    // Regular variable allocation - 4 bytes for int
    add_local_variable(ctx, name, 4);
    VariableLocation *loc = get_variable_location(ctx, name);
    fprintf(ctx->output, "    ; Initializing variable %s at offset %d\n", name,
            loc ? loc->stack_offset : 0);
  }

  // Generate initializer if present
  if (var->child_count > 0 && var->children[0]) {
    codegen_expression(var->children[0], ctx, "t0");
    VariableLocation *loc = get_variable_location(ctx, name);
    if (loc) {
      emit_instruction(ctx, "sw", "t0, %d(s0)", loc->stack_offset);
    } else {
      // Global variable
      emit_instruction(ctx, "la", "t2, %s", name);
      emit_instruction(ctx, "sw", "t0, 0(t2)");
    }
  }
}

// Generate code for statements
void codegen_statement(AstNode *stmt, CodegenContext *ctx) {
  if (!stmt)
    return;

  switch (stmt->type) {
  case AST_IF_STMT:
    codegen_if_stmt(stmt, ctx);
    break;

  case AST_WHILE_STMT:
    codegen_while_stmt(stmt, ctx);
    break;

  case AST_FOR_STMT:
    codegen_for_stmt(stmt, ctx);
    break;

  case AST_RETURN_STMT:
    codegen_return_stmt(stmt, ctx);
    break;

  case AST_BREAK_STMT:
    if (ctx->break_label >= 0) {
      emit_instruction(ctx, "j", "L%d", ctx->break_label);
    }
    break;

  case AST_CONTINUE_STMT:
    if (ctx->continue_label >= 0) {
      emit_instruction(ctx, "j", "L%d", ctx->continue_label);
    }
    break;

  case AST_EXPRESSION_STMT:
    if (stmt->child_count > 0) {
      codegen_expression(stmt->children[0], ctx, "a0");
    }
    break;

  default:
    codegen_node(stmt, ctx);
    break;
  }
}

// Generate code for expressions
void codegen_expression(AstNode *expr, CodegenContext *ctx,
                        const char *result_reg) {
  if (!expr)
    return;

  switch (expr->type) {
  case AST_INT_LITERAL:
  case AST_FLOAT_LITERAL:
  case AST_CHAR_LITERAL:
  case AST_STRING_LITERAL:
    codegen_literal(expr, ctx, result_reg);
    break;

  case AST_IDENTIFIER:
    codegen_identifier(expr, ctx, result_reg);
    break;

  case AST_BINARY_OP:
    codegen_binary_op(expr, ctx, result_reg);
    break;

  case AST_UNARY_OP:
    codegen_unary_op(expr, ctx, result_reg);
    break;

  case AST_POSTFIX_OP:
    codegen_postfix_op(expr, ctx, result_reg);
    break;

  case AST_TERNARY_OP:
    codegen_ternary_op(expr, ctx, result_reg);
    break;

  case AST_ASSIGNMENT:
    codegen_assignment(expr, ctx, result_reg);
    break;

  case AST_FUNCTION_CALL:
    codegen_function_call(expr, ctx, result_reg);
    break;

  case AST_ARRAY_ACCESS:
    // Generate array access: array[index]
    // Calculate: base_address + (index * element_size)
    codegen_expression(expr->children[0], ctx, "t0"); // Array base address
    codegen_expression(expr->children[1], ctx, "t1"); // Index
    // Check type for scale
    int scale = 2; // Default << 2 (x4)
    if (expr->children[0]->data_type &&
        expr->children[0]->data_type->element_type &&
        expr->children[0]->data_type->element_type->base_type == TYPE_CHAR) {
      scale = 0;
    }

    if (scale > 0)
      emit_instruction(ctx, "slli", "t1, t1, %d", scale);
    emit_instruction(ctx, "add", "t0, t0, t1"); // Calculate final address
    if (scale == 0) {
      emit_instruction(ctx, "lb", "%s, 0(t0)",
                       result_reg); // Load byte for char
    } else {
      emit_instruction(ctx, "lw", "%s, 0(t0)", result_reg); // Load word
    }
    break;

  case AST_MEMBER_ACCESS:
  case AST_POINTER_ACCESS:
    // Simplified member access
    codegen_expression(expr->children[0], ctx, result_reg);
    emit_comment(ctx, "Member access (simplified)");
    break;

  default:
    emit_comment(ctx, "Unknown expression type");
    break;
  }
}

// Generate code for binary operations
void codegen_binary_op(AstNode *expr, CodegenContext *ctx,
                       const char *result_reg) {
  TokenType op = expr->data.binary_op.op;

  // Generate code for operands
  codegen_expression(expr->children[0], ctx, "t0");
  codegen_expression(expr->children[1], ctx, "t1");

  switch (op) {
  case TOK_PLUS:
    emit_instruction(ctx, "add", "%s, t0, t1", result_reg);
    break;
  case TOK_MINUS:
    emit_instruction(ctx, "sub", "%s, t0, t1", result_reg);
    break;
  case TOK_MULTIPLY:
    emit_instruction(ctx, "mul", "%s, t0, t1", result_reg);
    break;
  case TOK_DIVIDE:
    emit_instruction(ctx, "div", "%s, t0, t1", result_reg);
    break;
  case TOK_MODULO:
    emit_instruction(ctx, "rem", "%s, t0, t1", result_reg);
    break;

  case TOK_EQ:
    // t0 == t1 -> sub t2, t0, t1; sltiu res, t2, 1
    emit_instruction(ctx, "sub", "t2, t0, t1");
    emit_instruction(ctx, "sltiu", "%s, t2, 1", result_reg);
    break;
  case TOK_NE:
    // t0 != t1 -> sub t2, t0, t1; sltu res, zero, t2
    emit_instruction(ctx, "sub", "t2, t0, t1");
    emit_instruction(ctx, "sltu", "%s, zero, t2", result_reg);
    break;
  case TOK_LT:
    emit_instruction(ctx, "slt", "%s, t0, t1", result_reg);
    break;
  case TOK_LE:
    // t0 <= t1 -> !(t1 < t0)
    emit_instruction(ctx, "slt", "t2, t1, t0");
    emit_instruction(ctx, "xori", "%s, t2, 1", result_reg);
    break;
  case TOK_GT:
    // t0 > t1 -> t1 < t0
    emit_instruction(ctx, "slt", "%s, t1, t0", result_reg);
    break;
  case TOK_GE:
    // t0 >= t1 -> !(t0 < t1)
    emit_instruction(ctx, "slt", "t2, t0, t1");
    emit_instruction(ctx, "xori", "%s, t2, 1", result_reg);
    break;

  case TOK_AND:
  case TOK_BITAND:
    emit_instruction(ctx, "and", "%s, t0, t1", result_reg);
    break;
  case TOK_OR:
  case TOK_BITOR:
    emit_instruction(ctx, "or", "%s, t0, t1", result_reg);
    break;
  case TOK_BITXOR:
    emit_instruction(ctx, "xor", "%s, t0, t1", result_reg);
    break;
  case TOK_SHL:
    emit_instruction(ctx, "sll", "%s, t0, t1", result_reg);
    break;
  case TOK_SHR:
    emit_instruction(ctx, "sra", "%s, t0, t1",
                     result_reg); // arithmetic shift for int
    break;

  default:
    emit_comment(ctx, "Unknown binary operator");
    break;
  }
}

// Helper to store a value to an lvalue expression
void codegen_store_lvalue(AstNode *lvalue, CodegenContext *ctx,
                          const char *src_reg) {
  if (lvalue->type == AST_IDENTIFIER) {
    const char *var_name = lvalue->data.identifier.name;
    VariableLocation *loc = get_variable_location(ctx, var_name);
    if (loc) {
      // Local variable
      emit_instruction(ctx, "sw", "%s, %d(s0)", src_reg, loc->stack_offset);
    } else {
      // Global variable
      emit_instruction(ctx, "la", "t3, %s", var_name);
      emit_instruction(ctx, "sw", "%s, 0(t3)", src_reg);
    }
  } else if (lvalue->type == AST_ARRAY_ACCESS) {
    fprintf(ctx->output, "    ; Store back to array element\n");
    // We need to preserve src_reg, so use t4, t5
    codegen_expression(lvalue->children[0], ctx, "t4"); // base
    codegen_expression(lvalue->children[1], ctx, "t5"); // index
    int scale = 2;
    if (lvalue->children[0]->data_type &&
        lvalue->children[0]->data_type->element_type &&
        lvalue->children[0]->data_type->element_type->base_type == TYPE_CHAR) {
      scale = 0;
    }
    if (scale > 0)
      emit_instruction(ctx, "slli", "t5, t5, %d", scale);
    emit_instruction(ctx, "add", "t4, t4, t5"); // Address
    if (scale == 0) {
      emit_instruction(ctx, "sb", "%s, 0(t4)", src_reg);
    } else {
      emit_instruction(ctx, "sw", "%s, 0(t4)", src_reg);
    }
  } else if (lvalue->type == AST_UNARY_OP &&
             lvalue->data.unary_op.op == TOK_MULTIPLY) {
    fprintf(ctx->output, "    ; Store back to pointer dereference\n");
    codegen_expression(lvalue->children[0], ctx, "t4"); // address
    if (lvalue->data_type && lvalue->data_type->base_type == TYPE_CHAR) {
      emit_instruction(ctx, "sb", "%s, 0(t4)", src_reg);
    } else {
      emit_instruction(ctx, "sw", "%s, 0(t4)", src_reg);
    }
  }
}

// Generate code for unary operations
void codegen_unary_op(AstNode *expr, CodegenContext *ctx,
                      const char *result_reg) {
  TokenType op = expr->data.unary_op.op;

  codegen_expression(expr->children[0], ctx, "t0");

  switch (op) {
  case TOK_MINUS:
    emit_instruction(ctx, "neg", "%s, t0",
                     result_reg); // neg is pseudo for sub 0, rs
    // If neg not supported, use sub result, zero, t0
    break;
  case TOK_PLUS:
    emit_instruction(ctx, "mv", "%s, t0", result_reg);
    break;
  case TOK_NOT: // Logical NOT (!x)
    // !x -> (x == 0) -> sltiu result, x, 1
    emit_instruction(ctx, "sltiu", "%s, t0, 1", result_reg);
    break;
  case TOK_BITNOT: // Bitwise NOT (~x)
    emit_instruction(ctx, "xori", "%s, t0, -1", result_reg);
    break;
  case TOK_INCREMENT:
    emit_instruction(ctx, "addi", "%s, t0, 1", result_reg);
    // Store back
    codegen_store_lvalue(expr->children[0], ctx, result_reg);
    break;
  case TOK_MULTIPLY: // Dereference (*ptr)
    if (expr->data_type && expr->data_type->base_type == TYPE_CHAR) {
      emit_instruction(ctx, "lb", "%s, 0(t0)", result_reg);
    } else {
      emit_instruction(ctx, "lw", "%s, 0(t0)", result_reg);
    }
    break;
  case TOK_BITAND: // Address-of (&var)
    if (expr->children[0]->type == AST_IDENTIFIER) {
      const char *var_name = expr->children[0]->data.identifier.name;
      VariableLocation *loc = get_variable_location(ctx, var_name);
      if (loc) {
        emit_instruction(ctx, "addi", "%s, s0, %d", result_reg,
                         loc->stack_offset);
      } else {
        emit_instruction(ctx, "la", "%s, %s", result_reg, var_name);
      }
    }
    break;
  case TOK_DECREMENT:
    emit_instruction(ctx, "addi", "%s, t0, -1", result_reg);
    // Store back
    codegen_store_lvalue(expr->children[0], ctx, result_reg);
    break;
  default:
    fprintf(stderr, "Unknown unary operator\n");
  }
}

// Generate code for postfix operations
void codegen_postfix_op(AstNode *expr, CodegenContext *ctx,
                        const char *result_reg) {
  TokenType op = expr->data.unary_op.op;

  codegen_expression(expr->children[0], ctx, "t0");  // Old value
  emit_instruction(ctx, "mv", "%s, t0", result_reg); // Return old value

  if (op == TOK_INCREMENT) {
    emit_instruction(ctx, "addi", "t1, t0, 1");
    codegen_store_lvalue(expr->children[0], ctx, "t1");
  } else if (op == TOK_DECREMENT) {
    emit_instruction(ctx, "addi", "t1, t0, -1");
    codegen_store_lvalue(expr->children[0], ctx, "t1");
  }
}

// Generate code for ternary operator (condition ? true_expr : false_expr)
void codegen_ternary_op(AstNode *expr, CodegenContext *ctx,
                        const char *result_reg) {
  static int label_counter = 0;
  int current_label = label_counter++;

  char false_label[32];
  char end_label[32];
  snprintf(false_label, sizeof(false_label), "L_ternary_false_%d",
           current_label);
  snprintf(end_label, sizeof(end_label), "L_ternary_end_%d", current_label);

  emit_comment(ctx, "Ternary operator: condition ? true : false");

  // Evaluate condition
  codegen_expression(expr->children[0], ctx, "t0");

  // Jump to false branch if condition is zero
  // emit_instruction(ctx, "cmp", "r1, #0");
  // emit_instruction(ctx, "je", "%s", false_label);
  emit_instruction(ctx, "beq", "t0, zero, %s", false_label);

  // True branch
  codegen_expression(expr->children[1], ctx, result_reg);
  emit_instruction(ctx, "j", "%s", end_label);

  // False branch
  fprintf(ctx->output, "%s:\n", false_label);
  codegen_expression(expr->children[2], ctx, result_reg);

  // End label
  fprintf(ctx->output, "%s:\n", end_label);
}

// Generate code for assignment
void codegen_assignment(AstNode *expr, CodegenContext *ctx,
                        const char *result_reg) {
  TokenType op = expr->data.assignment.op;

  // Handle compound assignments by expanding them to regular assignments
  if (op != TOK_ASSIGN) {
    emit_comment(ctx, "Compound assignment - expanding to regular assignment");

    // For compound assignment: lval OP= rval becomes lval = lval OP rval
    // First, load current value of left-hand side
    if (expr->children[0]->type == AST_IDENTIFIER) {
      const char *var_name = expr->children[0]->data.identifier.name;
      fprintf(ctx->output, "    ; Load current value of %s\n", var_name);

      // Check if it's a local variable
      VariableLocation *loc = get_variable_location(ctx, var_name);
      if (loc) {
        // Local variable - use stack-relative addressing
        emit_instruction(ctx, "lw", "t1, %d(s0)", loc->stack_offset);
      } else {
        // Global variable
        emit_instruction(ctx, "la", "t2, %s", var_name);
        emit_instruction(ctx, "lw", "t1, 0(t2)");
      }
    } else if (expr->children[0]->type == AST_ARRAY_ACCESS) {
      // Load current array element value
      fprintf(ctx->output, "    ; Load current array element value\n");
      codegen_expression(expr->children[0]->children[0], ctx,
                         "t1"); // Array base
      codegen_expression(expr->children[0]->children[1], ctx, "t2"); // Index
      int scale = 2;
      if (expr->children[0]->children[0]->data_type &&
          expr->children[0]->children[0]->data_type->element_type &&
          expr->children[0]->children[0]->data_type->element_type->base_type ==
              TYPE_CHAR) {
        scale = 0;
      }
      if (scale > 0)
        emit_instruction(ctx, "slli", "t2, t2, %d", scale);
      emit_instruction(ctx, "add", "t1, t1, t2"); // Calculate address
      if (scale == 0) {
        emit_instruction(ctx, "lb", "t1, 0(t1)");
      } else {
        emit_instruction(ctx, "lw", "t1, 0(t1)");
      }
    } else {
      fprintf(ctx->output, "    ; Load current value (complex lvalue)\n");
      emit_instruction(ctx, "mv", "t1, zero"); // Fallback
    }

    // Generate code for right-hand side
    codegen_expression(expr->children[1], ctx, "t2");

    // Perform the compound operation
    switch (op) {
    case TOK_PLUS_ASSIGN:
      emit_instruction(ctx, "add", "t0, t1, t2");
      break;
    case TOK_MINUS_ASSIGN:
      emit_instruction(ctx, "sub", "t0, t1, t2");
      break;
    case TOK_MUL_ASSIGN:
      emit_instruction(ctx, "mul", "t0, t1, t2");
      break;
    case TOK_DIV_ASSIGN:
      emit_instruction(ctx, "div", "t0, t1, t2");
      break;
    default:
      emit_comment(ctx, "Unknown compound assignment operator");
      emit_instruction(ctx, "mv", "t0, t2"); // Fallback to simple assignment
      break;
    }
  } else {
    // Regular assignment: just generate code for right-hand side
    codegen_expression(expr->children[1], ctx, "t0");
  }

  // Store to left-hand side
  codegen_store_lvalue(expr->children[0], ctx, "t0");

  // Assignment result is the assigned value
  emit_instruction(ctx, "mv", "%s, t0", result_reg);
}

// Generate code for function call
void codegen_function_call(AstNode *expr, CodegenContext *ctx,
                           const char *result_reg) {
  // Get function name
  if (expr->children[0]->type == AST_IDENTIFIER) {
    const char *func_name = expr->children[0]->data.identifier.name;

    emit_comment(ctx, "Function call");

    // Push arguments
    if (expr->child_count > 1) {
      AstNode *args = expr->children[1];
      for (int i = 0; i < args->child_count; i++) {
        codegen_expression(args->children[i], ctx, "t2");
        emit_instruction(ctx, "addi", "sp, sp, -4");
        emit_instruction(ctx, "sw", "t2, 0(sp)");
      }
    }

    // Call function
    emit_instruction(ctx, "call", "%s", func_name);

    // Clean up stack
    if (expr->child_count > 1) {
      AstNode *args = expr->children[1];
      if (args->child_count > 0) {
        emit_instruction(ctx, "addi", "sp, sp, %d", args->child_count * 4);
      }
    }

    // Move return value to result register
    emit_instruction(ctx, "mv", "%s, a0", result_reg);
  }
}

// Generate code for identifier
void codegen_identifier(AstNode *expr, CodegenContext *ctx,
                        const char *result_reg) {
  const char *name = expr->data.identifier.name;

  // Check if it's a local variable first
  VariableLocation *var = ctx->local_vars;
  while (var) {
    if (strcmp(var->name, name) == 0) {
      if (expr->data_type && expr->data_type->base_type == TYPE_ARRAY) {
        // For array, result is the address (decay to pointer)
        emit_instruction(ctx, "addi", "%s, s0, %d", result_reg,
                         var->stack_offset);
      } else {
        // Regular variable - load value
        emit_instruction(ctx, "lw", "%s, %d(s0)", result_reg,
                         var->stack_offset);
      }
      return;
    }
    var = var->next;
  }

  // Look up symbol to determine if it's a variable, function, etc.
  Symbol *symbol = lookup_symbol(ctx->symbols, name);
  if (symbol) {
    switch (symbol->symbol_type) {
    case SYMBOL_VARIABLE:
      // Global variable
      if (expr->data_type && expr->data_type->base_type == TYPE_ARRAY) {
        // Global array - result is the address
        emit_instruction(ctx, "la", "%s, %s", result_reg, name);
      } else {
        emit_instruction(ctx, "la", "t2, %s", name);
        emit_instruction(ctx, "lw", "%s, 0(t2)", result_reg);
      }
      break;
    case SYMBOL_FUNCTION:
      emit_instruction(ctx, "la", "%s, %s", result_reg, name);
      break;
    default:
      emit_comment(ctx, "Unknown symbol type");
      break;
    }
  } else {
    emit_comment(ctx, "Undefined symbol");
    emit_instruction(ctx, "li", "%s, 0", result_reg);
  }
}

// Generate code for literals
void codegen_literal(AstNode *expr, CodegenContext *ctx,
                     const char *result_reg) {
  switch (expr->type) {
  case AST_INT_LITERAL:
    emit_instruction(ctx, "li", "%s, %d", result_reg,
                     expr->data.int_literal.value);
    break;

  case AST_FLOAT_LITERAL:
    // Assuming soft-float or just passing raw bits
    emit_instruction(ctx, "li", "%s, %d", result_reg,
                     (int)expr->data.float_literal.value);
    break;

  case AST_CHAR_LITERAL:
    emit_instruction(ctx, "li", "%s, %d", result_reg,
                     (int)expr->data.char_literal.value);
    break;

  case AST_STRING_LITERAL: {
    int label = get_next_label(ctx);
    fprintf(ctx->output, "    la %s, str%d\n", result_reg, label);
    fprintf(ctx->output, "    j str%d_end\n", label);
    fprintf(ctx->output, "str%d: .string \"%s\"\n", label,
            expr->data.string_literal.value);
    fprintf(ctx->output, "str%d_end:\n", label);
    break;
  }

  default:
    emit_comment(ctx, "Unknown literal type");
    break;
  }
}

// Generate code for if statement
void codegen_if_stmt(AstNode *stmt, CodegenContext *ctx) {
  int else_label = get_next_label(ctx);
  int end_label = get_next_label(ctx);

  emit_comment(ctx, "If statement");

  // Generate condition
  if (stmt->child_count > 0) {
    codegen_expression(stmt->children[0], ctx, "a0");
    // emit_instruction(ctx, "cmp", "r0, #0");
    // emit_instruction(ctx, "je", "L%d", else_label);
    emit_instruction(ctx, "beq", "a0, zero, L%d", else_label);
  }

  // Generate then branch
  if (stmt->child_count > 1) {
    codegen_node(stmt->children[1], ctx);
  }

  emit_instruction(ctx, "j", "L%d", end_label);

  // Generate else branch
  emit_label(ctx, else_label);
  if (stmt->child_count > 2) {
    codegen_node(stmt->children[2], ctx);
  }

  emit_label(ctx, end_label);
}

// Generate code for while statement
void codegen_while_stmt(AstNode *stmt, CodegenContext *ctx) {
  int start_label = get_next_label(ctx);
  int end_label = get_next_label(ctx);

  int old_break = ctx->break_label;
  int old_continue = ctx->continue_label;
  ctx->break_label = end_label;
  ctx->continue_label = start_label;

  emit_comment(ctx, "While loop");
  emit_label(ctx, start_label);

  // Generate condition
  if (stmt->child_count > 0) {
    codegen_expression(stmt->children[0], ctx, "a0");
    // emit_instruction(ctx, "cmp", "r0, #0");
    // emit_instruction(ctx, "je", "L%d", end_label);
    emit_instruction(ctx, "beq", "a0, zero, L%d", end_label);
  }

  // Generate body
  if (stmt->child_count > 1) {
    codegen_node(stmt->children[1], ctx);
  }

  emit_instruction(ctx, "j", "L%d", start_label);
  emit_label(ctx, end_label);

  ctx->break_label = old_break;
  ctx->continue_label = old_continue;
}

// Generate code for for statement (simplified)
void codegen_for_stmt(AstNode *stmt, CodegenContext *ctx) {
  emit_comment(ctx, "For loop (simplified)");

  // For now, just generate the body
  if (stmt->child_count > 0) {
    codegen_node(stmt->children[stmt->child_count - 1], ctx);
  }
}

// Generate code for return statement
void codegen_return_stmt(AstNode *stmt, CodegenContext *ctx) {
  emit_comment(ctx, "Return statement");

  // Generate return value
  if (stmt->child_count > 0) {
    codegen_expression(stmt->children[0], ctx, "a0");
  } else {
    emit_instruction(ctx, "li", "a0, 0");
  }

  // Jump to function epilogue
  emit_instruction(ctx, "addi", "sp, sp, 256");
  emit_instruction(ctx, "lw", "s0, 8(sp)");
  emit_instruction(ctx, "lw", "ra, 12(sp)");
  emit_instruction(ctx, "addi", "sp, sp, 16");
  emit_instruction(ctx, "ret", "");
}

// Utility functions
int get_next_label(CodegenContext *ctx) { return ctx->label_counter++; }

const char *get_temp_register(CodegenContext *ctx) {
  static char temp_reg[8];
  snprintf(temp_reg, sizeof(temp_reg), "t%d", ctx->temp_counter++);
  return temp_reg;
}

void emit_label(CodegenContext *ctx, int label) {
  fprintf(ctx->output, "L%d:\n", label);
}

void emit_instruction(CodegenContext *ctx, const char *op, const char *args,
                      ...) {
  va_list va_args;
  va_start(va_args, args);

  fprintf(ctx->output, "    %s ", op);
  if (args) {
    vfprintf(ctx->output, args, va_args);
  }
  fprintf(ctx->output, "\n");

  va_end(va_args);
}

void emit_comment(CodegenContext *ctx, const char *comment) {
  fprintf(ctx->output, "    ; %s\n", comment);
}

// Emit runtime support functions
void emit_runtime_functions(CodegenContext *ctx) {
  emit_comment(ctx, "Runtime support functions");

  fprintf(ctx->output, "malloc:\n");
  fprintf(ctx->output, "    ; Simple malloc - returns fixed heap addresses\n");
  fprintf(ctx->output, "    la t0, heap_ptr\n");
  fprintf(ctx->output, "    lw t1, 0(t0)\n");
  fprintf(ctx->output, "    add t2, t1, a0\n");
  fprintf(ctx->output, "    sw t2, 0(t0)\n");
  fprintf(ctx->output, "    mv a0, t1\n");
  fprintf(ctx->output, "    ret\n\n");

  // Simple putchar implementation
  fprintf(ctx->output, "putchar:\n");
  fprintf(ctx->output, "    ; Output character in a0\n");
  fprintf(ctx->output, "    li a7, 1\n"); // System call for print
  fprintf(ctx->output, "    ecall\n");
  fprintf(ctx->output, "    ret\n\n");

  // Simple strlen implementation
  fprintf(ctx->output, "strlen:\n");
  fprintf(ctx->output, "    ; String length - string pointer in a0\n");
  fprintf(ctx->output, "    mv t0, a0\n");
  fprintf(ctx->output, "    li a0, 0\n");
  fprintf(ctx->output, "strlen_loop:\n");
  fprintf(ctx->output, "    lb t1, 0(t0)\n"); // Load byte
  fprintf(ctx->output, "    beq t1, zero, strlen_end\n");
  fprintf(ctx->output, "    addi a0, a0, 1\n");
  fprintf(ctx->output, "    addi t0, t0, 1\n");
  fprintf(ctx->output, "    j strlen_loop\n");
  fprintf(ctx->output, "strlen_end:\n");
  fprintf(ctx->output, "    ret\n\n");

  // Data section
  fprintf(ctx->output, "; Data section\n");
  // Align to 4 bytes
  fprintf(ctx->output, ".align 4\n");
  fprintf(ctx->output, "heap_ptr: .word 0x10000\n\n");
}

// Variable location management functions
void add_local_variable(CodegenContext *ctx, const char *name, int size) {
  VariableLocation *var = malloc(sizeof(VariableLocation));
  var->name = strdup(name);
  var->stack_offset = ctx->stack_offset - size;
  var->next = ctx->local_vars;
  ctx->local_vars = var;
  ctx->stack_offset -= size;
}

VariableLocation *get_variable_location(CodegenContext *ctx, const char *name) {
  VariableLocation *var = ctx->local_vars;
  while (var) {
    if (strcmp(var->name, name) == 0) {
      return var;
    }
    var = var->next;
  }
  return NULL; // Not found
}

void clear_local_variables(CodegenContext *ctx) {
  VariableLocation *var = ctx->local_vars;
  while (var) {
    VariableLocation *next = var->next;
    free(var->name);
    free(var);
    var = next;
  }
  ctx->local_vars = NULL;
  ctx->stack_offset = 0;
}
