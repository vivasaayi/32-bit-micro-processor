/*
 * Code Generator Implementation
 * Emits custom RISC assembly from AST
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include "codegen.h"

// Main code generation function
int generate_code(AstNode* ast, SymbolTable* symbols, FILE* output) {
    if (!ast || !symbols || !output) return 0;
    
    CodegenContext ctx = {
        .output = output,
        .symbols = symbols,
        .label_counter = 0,
        .temp_counter = 0,
        .current_function_offset = 0,
        .break_label = -1,
        .continue_label = -1
    };
    
    // Emit assembly header
    fprintf(output, "; Generated by Simple C Compiler\n");
    fprintf(output, "; Custom RISC Assembly Output\n\n");
    
    // Emit runtime functions
    emit_runtime_functions(&ctx);
    
    // Generate code for the entire program
    codegen_node(ast, &ctx);
    
    // Emit program entry point
    fprintf(output, "\n; Program entry point\n");
    fprintf(output, "_start:\n");
    fprintf(output, "    call main\n");
    fprintf(output, "    halt\n");
    
    return 1;
}

// Generate code for any AST node
void codegen_node(AstNode* node, CodegenContext* ctx) {
    if (!node) return;
    
    switch (node->type) {
        case AST_COMPOUND_STMT:
            emit_comment(ctx, "Compound statement");
            for (int i = 0; i < node->child_count; i++) {
                codegen_node(node->children[i], ctx);
            }
            break;
            
        case AST_FUNCTION_DECL:
        case AST_VARIABLE_DECL:
        case AST_STRUCT_DECL:
        case AST_ENUM_DECL:
        case AST_TYPEDEF_DECL:
            codegen_declaration(node, ctx);
            break;
            
        case AST_IF_STMT:
        case AST_WHILE_STMT:
        case AST_FOR_STMT:
        case AST_RETURN_STMT:
        case AST_BREAK_STMT:
        case AST_CONTINUE_STMT:
        case AST_EXPRESSION_STMT:
            codegen_statement(node, ctx);
            break;
            
        default:
            // For expressions and other nodes, generate into temp register
            codegen_expression(node, ctx, "r0");
            break;
    }
}

// Generate code for declarations
void codegen_declaration(AstNode* decl, CodegenContext* ctx) {
    if (!decl) return;
    
    switch (decl->type) {
        case AST_FUNCTION_DECL:
            codegen_function_decl(decl, ctx);
            break;
            
        case AST_VARIABLE_DECL:
            codegen_variable_decl(decl, ctx);
            break;
            
        case AST_STRUCT_DECL:
        case AST_ENUM_DECL:
        case AST_TYPEDEF_DECL:
            // These don't generate runtime code, just type information
            emit_comment(ctx, "Type declaration (no runtime code)");
            break;
            
        default:
            break;
    }
}

// Generate code for function declaration
void codegen_function_decl(AstNode* func, CodegenContext* ctx) {
    const char* name = func->data.function_decl.name;
    
    emit_comment(ctx, "Function declaration");
    fprintf(ctx->output, "%s:\n", name);
    
    // Function prologue
    emit_instruction(ctx, "push", "fp");
    emit_instruction(ctx, "mov", "fp, sp");
    
    // Allocate space for local variables (simplified)
    emit_instruction(ctx, "sub", "sp, sp, #64");
    
    // Generate function body
    if (func->child_count > 1 && func->children[1]) {
        ctx->current_function_offset = 0;
        codegen_node(func->children[1], ctx);
    }
    
    // Function epilogue (if no explicit return)
    fprintf(ctx->output, "%s_end:\n", name);
    emit_instruction(ctx, "add", "sp, sp, #64");
    emit_instruction(ctx, "pop", "fp");
    emit_instruction(ctx, "ret", "");
    fprintf(ctx->output, "\n");
}

// Generate code for variable declaration
void codegen_variable_decl(AstNode* var, CodegenContext* ctx) {
    const char* name = var->data.variable_decl.name;
    
    emit_comment(ctx, "Variable declaration");
    
    // Allocate space for variable (simplified - just reserve a register or stack slot)
    fprintf(ctx->output, "; Variable %s allocated\n", name);
    
    // Generate initializer if present
    if (var->child_count > 0 && var->children[0]) {
        codegen_expression(var->children[0], ctx, "r1");
        fprintf(ctx->output, "    ; Store initializer value for %s\n", name);
        // In a real implementation, would store to variable's location
    }
}

// Generate code for statements
void codegen_statement(AstNode* stmt, CodegenContext* ctx) {
    if (!stmt) return;
    
    switch (stmt->type) {
        case AST_IF_STMT:
            codegen_if_stmt(stmt, ctx);
            break;
            
        case AST_WHILE_STMT:
            codegen_while_stmt(stmt, ctx);
            break;
            
        case AST_FOR_STMT:
            codegen_for_stmt(stmt, ctx);
            break;
            
        case AST_RETURN_STMT:
            codegen_return_stmt(stmt, ctx);
            break;
            
        case AST_BREAK_STMT:
            if (ctx->break_label >= 0) {
                emit_instruction(ctx, "jmp", "L%d", ctx->break_label);
            }
            break;
            
        case AST_CONTINUE_STMT:
            if (ctx->continue_label >= 0) {
                emit_instruction(ctx, "jmp", "L%d", ctx->continue_label);
            }
            break;
            
        case AST_EXPRESSION_STMT:
            if (stmt->child_count > 0) {
                codegen_expression(stmt->children[0], ctx, "r0");
            }
            break;
            
        default:
            codegen_node(stmt, ctx);
            break;
    }
}

// Generate code for expressions
void codegen_expression(AstNode* expr, CodegenContext* ctx, const char* result_reg) {
    if (!expr) return;
    
    switch (expr->type) {
        case AST_INT_LITERAL:
        case AST_FLOAT_LITERAL:
        case AST_CHAR_LITERAL:
        case AST_STRING_LITERAL:
            codegen_literal(expr, ctx, result_reg);
            break;
            
        case AST_IDENTIFIER:
            codegen_identifier(expr, ctx, result_reg);
            break;
            
        case AST_BINARY_OP:
            codegen_binary_op(expr, ctx, result_reg);
            break;
            
        case AST_UNARY_OP:
            codegen_unary_op(expr, ctx, result_reg);
            break;
            
        case AST_ASSIGNMENT:
            codegen_assignment(expr, ctx, result_reg);
            break;
            
        case AST_FUNCTION_CALL:
            codegen_function_call(expr, ctx, result_reg);
            break;
            
        case AST_ARRAY_ACCESS:
            // Simplified array access
            codegen_expression(expr->children[0], ctx, "r1"); // Array base
            codegen_expression(expr->children[1], ctx, "r2"); // Index
            emit_instruction(ctx, "mul", "r2, r2, #4"); // Scale index
            emit_instruction(ctx, "add", "r1, r1, r2"); // Calculate address
            emit_instruction(ctx, "load", "%s, [r1]", result_reg); // Load value
            break;
            
        case AST_MEMBER_ACCESS:
        case AST_POINTER_ACCESS:
            // Simplified member access
            codegen_expression(expr->children[0], ctx, result_reg);
            emit_comment(ctx, "Member access (simplified)");
            break;
            
        default:
            emit_comment(ctx, "Unknown expression type");
            break;
    }
}

// Generate code for binary operations
void codegen_binary_op(AstNode* expr, CodegenContext* ctx, const char* result_reg) {
    TokenType op = expr->data.binary_op.operator;
    
    // Generate code for operands
    codegen_expression(expr->children[0], ctx, "r1");
    codegen_expression(expr->children[1], ctx, "r2");
    
    switch (op) {
        case TOK_PLUS:
            emit_instruction(ctx, "add", "%s, r1, r2", result_reg);
            break;
        case TOK_MINUS:
            emit_instruction(ctx, "sub", "%s, r1, r2", result_reg);
            break;
        case TOK_MULTIPLY:
            emit_instruction(ctx, "mul", "%s, r1, r2", result_reg);
            break;
        case TOK_DIVIDE:
            emit_instruction(ctx, "div", "%s, r1, r2", result_reg);
            break;
        case TOK_MODULO:
            emit_instruction(ctx, "mod", "%s, r1, r2", result_reg);
            break;
            
        case TOK_EQ:
            emit_instruction(ctx, "cmp", "r1, r2");
            emit_instruction(ctx, "seteq", "%s", result_reg);
            break;
        case TOK_NE:
            emit_instruction(ctx, "cmp", "r1, r2");
            emit_instruction(ctx, "setne", "%s", result_reg);
            break;
        case TOK_LT:
            emit_instruction(ctx, "cmp", "r1, r2");
            emit_instruction(ctx, "setlt", "%s", result_reg);
            break;
        case TOK_LE:
            emit_instruction(ctx, "cmp", "r1, r2");
            emit_instruction(ctx, "setle", "%s", result_reg);
            break;
        case TOK_GT:
            emit_instruction(ctx, "cmp", "r1, r2");
            emit_instruction(ctx, "setgt", "%s", result_reg);
            break;
        case TOK_GE:
            emit_instruction(ctx, "cmp", "r1, r2");
            emit_instruction(ctx, "setge", "%s", result_reg);
            break;
            
        case TOK_AND:
            emit_instruction(ctx, "and", "%s, r1, r2", result_reg);
            break;
        case TOK_OR:
            emit_instruction(ctx, "or", "%s, r1, r2", result_reg);
            break;
            
        case TOK_BITAND:
            emit_instruction(ctx, "and", "%s, r1, r2", result_reg);
            break;
        case TOK_BITOR:
            emit_instruction(ctx, "or", "%s, r1, r2", result_reg);
            break;
        case TOK_BITXOR:
            emit_instruction(ctx, "xor", "%s, r1, r2", result_reg);
            break;
        case TOK_SHL:
            emit_instruction(ctx, "shl", "%s, r1, r2", result_reg);
            break;
        case TOK_SHR:
            emit_instruction(ctx, "shr", "%s, r1, r2", result_reg);
            break;
            
        default:
            emit_comment(ctx, "Unknown binary operator");
            break;
    }
}

// Generate code for unary operations
void codegen_unary_op(AstNode* expr, CodegenContext* ctx, const char* result_reg) {
    TokenType op = expr->data.unary_op.operator;
    
    codegen_expression(expr->children[0], ctx, "r1");
    
    switch (op) {
        case TOK_MINUS:
            emit_instruction(ctx, "neg", "%s, r1", result_reg);
            break;
        case TOK_PLUS:
            emit_instruction(ctx, "mov", "%s, r1", result_reg);
            break;
        case TOK_NOT:
            emit_instruction(ctx, "not", "%s, r1", result_reg);
            break;
        case TOK_BITNOT:
            emit_instruction(ctx, "xor", "%s, r1, #-1", result_reg);
            break;
        case TOK_INCREMENT:
            emit_instruction(ctx, "add", "%s, r1, #1", result_reg);
            break;
        case TOK_DECREMENT:
            emit_instruction(ctx, "sub", "%s, r1, #1", result_reg);
            break;
        default:
            emit_comment(ctx, "Unknown unary operator");
            break;
    }
}

// Generate code for assignment
void codegen_assignment(AstNode* expr, CodegenContext* ctx, const char* result_reg) {
    // Generate code for right-hand side
    codegen_expression(expr->children[1], ctx, "r1");
    
    // Store to left-hand side (simplified)
    if (expr->children[0]->type == AST_IDENTIFIER) {
        const char* var_name = expr->children[0]->data.identifier.name;
        fprintf(ctx->output, "    ; Store to variable %s\n", var_name);
        emit_instruction(ctx, "store", "r1, [%s]", var_name);
    }
    
    // Assignment result is the assigned value
    emit_instruction(ctx, "mov", "%s, r1", result_reg);
}

// Generate code for function call
void codegen_function_call(AstNode* expr, CodegenContext* ctx, const char* result_reg) {
    // Get function name
    if (expr->children[0]->type == AST_IDENTIFIER) {
        const char* func_name = expr->children[0]->data.identifier.name;
        
        emit_comment(ctx, "Function call");
        
        // Push arguments (simplified - just evaluate them)
        if (expr->child_count > 1) {
            AstNode* args = expr->children[1];
            for (int i = 0; i < args->child_count; i++) {
                codegen_expression(args->children[i], ctx, "r3");
                emit_instruction(ctx, "push", "r3");
            }
        }
        
        // Call function
        emit_instruction(ctx, "call", "%s", func_name);
        
        // Clean up stack (simplified)
        if (expr->child_count > 1) {
            AstNode* args = expr->children[1];
            if (args->child_count > 0) {
                emit_instruction(ctx, "add", "sp, sp, #%d", args->child_count * 4);
            }
        }
        
        // Move return value to result register
        emit_instruction(ctx, "mov", "%s, r0", result_reg);
    }
}

// Generate code for identifier
void codegen_identifier(AstNode* expr, CodegenContext* ctx, const char* result_reg) {
    const char* name = expr->data.identifier.name;
    
    // Look up symbol to determine if it's a variable, function, etc.
    Symbol* symbol = lookup_symbol(ctx->symbols, name);
    if (symbol) {
        switch (symbol->symbol_type) {
            case SYMBOL_VARIABLE:
                emit_instruction(ctx, "load", "%s, [%s]", result_reg, name);
                break;
            case SYMBOL_FUNCTION:
                emit_instruction(ctx, "lea", "%s, %s", result_reg, name);
                break;
            default:
                emit_comment(ctx, "Unknown symbol type");
                break;
        }
    } else {
        emit_comment(ctx, "Undefined symbol");
        emit_instruction(ctx, "mov", "%s, #0", result_reg);
    }
}

// Generate code for literals
void codegen_literal(AstNode* expr, CodegenContext* ctx, const char* result_reg) {
    switch (expr->type) {
        case AST_INT_LITERAL:
            emit_instruction(ctx, "mov", "%s, #%d", result_reg, expr->data.int_literal.value);
            break;
            
        case AST_FLOAT_LITERAL:
            emit_instruction(ctx, "movf", "%s, #%f", result_reg, expr->data.float_literal.value);
            break;
            
        case AST_CHAR_LITERAL:
            emit_instruction(ctx, "mov", "%s, #%d", result_reg, (int)expr->data.char_literal.value);
            break;
            
        case AST_STRING_LITERAL: {
            int label = get_next_label(ctx);
            fprintf(ctx->output, "    lea %s, str%d\n", result_reg, label);
            fprintf(ctx->output, "    jmp str%d_end\n", label);
            fprintf(ctx->output, "str%d: .string \"%s\"\n", label, expr->data.string_literal.value);
            fprintf(ctx->output, "str%d_end:\n", label);
            break;
        }
            
        default:
            emit_comment(ctx, "Unknown literal type");
            break;
    }
}

// Generate code for if statement
void codegen_if_stmt(AstNode* stmt, CodegenContext* ctx) {
    int else_label = get_next_label(ctx);
    int end_label = get_next_label(ctx);
    
    emit_comment(ctx, "If statement");
    
    // Generate condition
    if (stmt->child_count > 0) {
        codegen_expression(stmt->children[0], ctx, "r0");
        emit_instruction(ctx, "cmp", "r0, #0");
        emit_instruction(ctx, "je", "L%d", else_label);
    }
    
    // Generate then branch
    if (stmt->child_count > 1) {
        codegen_node(stmt->children[1], ctx);
    }
    
    emit_instruction(ctx, "jmp", "L%d", end_label);
    
    // Generate else branch
    emit_label(ctx, else_label);
    if (stmt->child_count > 2) {
        codegen_node(stmt->children[2], ctx);
    }
    
    emit_label(ctx, end_label);
}

// Generate code for while statement
void codegen_while_stmt(AstNode* stmt, CodegenContext* ctx) {
    int start_label = get_next_label(ctx);
    int end_label = get_next_label(ctx);
    
    int old_break = ctx->break_label;
    int old_continue = ctx->continue_label;
    ctx->break_label = end_label;
    ctx->continue_label = start_label;
    
    emit_comment(ctx, "While loop");
    emit_label(ctx, start_label);
    
    // Generate condition
    if (stmt->child_count > 0) {
        codegen_expression(stmt->children[0], ctx, "r0");
        emit_instruction(ctx, "cmp", "r0, #0");
        emit_instruction(ctx, "je", "L%d", end_label);
    }
    
    // Generate body
    if (stmt->child_count > 1) {
        codegen_node(stmt->children[1], ctx);
    }
    
    emit_instruction(ctx, "jmp", "L%d", start_label);
    emit_label(ctx, end_label);
    
    ctx->break_label = old_break;
    ctx->continue_label = old_continue;
}

// Generate code for for statement (simplified)
void codegen_for_stmt(AstNode* stmt, CodegenContext* ctx) {
    emit_comment(ctx, "For loop (simplified)");
    
    // For now, just generate the body
    if (stmt->child_count > 0) {
        codegen_node(stmt->children[stmt->child_count - 1], ctx);
    }
}

// Generate code for return statement
void codegen_return_stmt(AstNode* stmt, CodegenContext* ctx) {
    emit_comment(ctx, "Return statement");
    
    // Generate return value
    if (stmt->child_count > 0) {
        codegen_expression(stmt->children[0], ctx, "r0");
    } else {
        emit_instruction(ctx, "mov", "r0, #0");
    }
    
    // Jump to function epilogue
    emit_instruction(ctx, "add", "sp, sp, #64");
    emit_instruction(ctx, "pop", "fp");
    emit_instruction(ctx, "ret", "");
}

// Utility functions
int get_next_label(CodegenContext* ctx) {
    return ctx->label_counter++;
}

const char* get_temp_register(CodegenContext* ctx) {
    static char temp_reg[8];
    snprintf(temp_reg, sizeof(temp_reg), "t%d", ctx->temp_counter++);
    return temp_reg;
}

void emit_label(CodegenContext* ctx, int label) {
    fprintf(ctx->output, "L%d:\n", label);
}

void emit_instruction(CodegenContext* ctx, const char* op, const char* args, ...) {
    va_list va_args;
    va_start(va_args, args);
    
    fprintf(ctx->output, "    %s ", op);
    if (args) {
        vfprintf(ctx->output, args, va_args);
    }
    fprintf(ctx->output, "\n");
    
    va_end(va_args);
}

void emit_comment(CodegenContext* ctx, const char* comment) {
    fprintf(ctx->output, "    ; %s\n", comment);
}

// Emit runtime support functions
void emit_runtime_functions(CodegenContext* ctx) {
    emit_comment(ctx, "Runtime support functions");
    
    // Simple malloc implementation (just returns fixed addresses)
    fprintf(ctx->output, "malloc:\n");
    fprintf(ctx->output, "    ; Simple malloc - returns fixed heap addresses\n");
    fprintf(ctx->output, "    load r1, heap_ptr\n");
    fprintf(ctx->output, "    add r2, r1, r0\n");
    fprintf(ctx->output, "    store r2, heap_ptr\n");
    fprintf(ctx->output, "    mov r0, r1\n");
    fprintf(ctx->output, "    ret\n\n");
    
    // Simple putchar implementation
    fprintf(ctx->output, "putchar:\n");
    fprintf(ctx->output, "    ; Output character in r0\n");
    fprintf(ctx->output, "    out r0\n");
    fprintf(ctx->output, "    ret\n\n");
    
    // Simple strlen implementation
    fprintf(ctx->output, "strlen:\n");
    fprintf(ctx->output, "    ; String length - string pointer in r0\n");
    fprintf(ctx->output, "    mov r1, r0\n");
    fprintf(ctx->output, "    mov r0, #0\n");
    fprintf(ctx->output, "strlen_loop:\n");
    fprintf(ctx->output, "    load r2, [r1]\n");
    fprintf(ctx->output, "    cmp r2, #0\n");
    fprintf(ctx->output, "    je strlen_end\n");
    fprintf(ctx->output, "    add r0, r0, #1\n");
    fprintf(ctx->output, "    add r1, r1, #1\n");
    fprintf(ctx->output, "    jmp strlen_loop\n");
    fprintf(ctx->output, "strlen_end:\n");
    fprintf(ctx->output, "    ret\n\n");
    
    // Data section
    fprintf(ctx->output, "; Data section\n");
    fprintf(ctx->output, "heap_ptr: .word 0x10000\n\n");
}
