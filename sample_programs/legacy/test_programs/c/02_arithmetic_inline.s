# Generated by Simple C Compiler
# Custom RISC Assembly Output

# Runtime support functions
malloc:
# Simple malloc - returns fixed heap addresses
load x1, heap_ptr
add x2, x1, x0
store x2, heap_ptr
mov x0, x1
ret

putchar:
# Output character in r0
li a7, 11
    ecall  # print char from x0
ret

strlen:
# String length - string pointer in r0
mov x1, x0
addi x0, zero, 0
strlen_loop:
lw x2, 0(x1)
#cmp x2, #0
je strlen_end
add x0, x0, #1
add x1, x1, #1
j strlen_loop
strlen_end:
ret

# Data section
heap_ptr: .word 0x10000

# Compound statement
# Function declaration
main:
addi sp, sp, -4
    sw fp, 0(sp)
mov fp, sp
sub sp, sp, #64
# Compound statement
# Variable declaration
# Variable a allocated at [fp-4]
addi x1, zero, 10
# Store initializer value for a
sw x1, 0(fp-4)
# Variable declaration
# Variable b allocated at [fp-8]
addi x1, zero, 3
# Store initializer value for b
sw x1, 0(fp-8)
# Variable declaration
# Variable result allocated at [fp-12]
# Function call
lea x3, str0
j str0_end
str0: .string "=== Arithmetic Test ===
"
str0_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
lw x1, 0(fp-4)
lw x2, 0(fp-8)
add x1, x1, x2
# Store to variable result
sw x1, 0(fp-12)
mov x0, x1
# Function call
lea x3, str1
j str1_end
str1: .string "10 + 3 = "
str1_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
# If statement
lw x1, 0(fp-12)
addi x2, zero, 13
#cmp x1, x2
seteq x0
#cmp x0, #0
je L2
# Compound statement
# Function call
lea x3, str4
j str4_end
str4: .string "13"
str4_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L3
L2:
# If statement
lw x1, 0(fp-12)
addi x2, zero, 0
#cmp x1, x2
seteq x0
#cmp x0, #0
je L5
# Compound statement
# Function call
lea x3, str7
j str7_end
str7: .string "0"
str7_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L6
L5:
# Compound statement
# Function call
lea x3, str8
j str8_end
str8: .string "?"
str8_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
L6:
L3:
# Function call
lea x3, str9
j str9_end
str9: .string "
"
str9_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
lw x1, 0(fp-4)
lw x2, 0(fp-8)
sub x1, x1, x2
# Store to variable result
sw x1, 0(fp-12)
mov x0, x1
# Function call
lea x3, str10
j str10_end
str10: .string "10 - 3 = "
str10_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
# If statement
lw x1, 0(fp-12)
addi x2, zero, 7
#cmp x1, x2
seteq x0
#cmp x0, #0
je L11
# Compound statement
# Function call
lea x3, str13
j str13_end
str13: .string "7"
str13_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L12
L11:
# If statement
lw x1, 0(fp-12)
addi x2, zero, 0
#cmp x1, x2
seteq x0
#cmp x0, #0
je L14
# Compound statement
# Function call
lea x3, str16
j str16_end
str16: .string "0"
str16_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L15
L14:
# Compound statement
# Function call
lea x3, str17
j str17_end
str17: .string "?"
str17_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
L15:
L12:
# Function call
lea x3, str18
j str18_end
str18: .string "
"
str18_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
lw x1, 0(fp-4)
lw x2, 0(fp-8)
mul x1, x1, x2
# Store to variable result
sw x1, 0(fp-12)
mov x0, x1
# Function call
lea x3, str19
j str19_end
str19: .string "10 * 3 = "
str19_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
# If statement
lw x1, 0(fp-12)
addi x2, zero, 30
#cmp x1, x2
seteq x0
#cmp x0, #0
je L20
# Compound statement
# Function call
lea x3, str22
j str22_end
str22: .string "30"
str22_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L21
L20:
# If statement
lw x1, 0(fp-12)
addi x2, zero, 0
#cmp x1, x2
seteq x0
#cmp x0, #0
je L23
# Compound statement
# Function call
lea x3, str25
j str25_end
str25: .string "0"
str25_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L24
L23:
# Compound statement
# Function call
lea x3, str26
j str26_end
str26: .string "?"
str26_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
L24:
L21:
# Function call
lea x3, str27
j str27_end
str27: .string "
"
str27_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
lw x1, 0(fp-4)
lw x2, 0(fp-8)
div x1, x1, x2
# Store to variable result
sw x1, 0(fp-12)
mov x0, x1
# Function call
lea x3, str28
j str28_end
str28: .string "10 / 3 = "
str28_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
# If statement
lw x1, 0(fp-12)
addi x2, zero, 3
#cmp x1, x2
seteq x0
#cmp x0, #0
je L29
# Compound statement
# Function call
lea x3, str31
j str31_end
str31: .string "3"
str31_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L30
L29:
# If statement
lw x1, 0(fp-12)
addi x2, zero, 0
#cmp x1, x2
seteq x0
#cmp x0, #0
je L32
# Compound statement
# Function call
lea x3, str34
j str34_end
str34: .string "0"
str34_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L33
L32:
# Compound statement
# Function call
lea x3, str35
j str35_end
str35: .string "?"
str35_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
L33:
L30:
# Function call
lea x3, str36
j str36_end
str36: .string "
"
str36_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
lw x1, 0(fp-4)
lw x2, 0(fp-8)
mod x1, x1, x2
# Store to variable result
sw x1, 0(fp-12)
mov x0, x1
# Function call
lea x3, str37
j str37_end
str37: .string "10 % 3 = "
str37_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
# If statement
lw x1, 0(fp-12)
addi x2, zero, 1
#cmp x1, x2
seteq x0
#cmp x0, #0
je L38
# Compound statement
# Function call
lea x3, str40
j str40_end
str40: .string "1"
str40_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L39
L38:
# If statement
lw x1, 0(fp-12)
addi x2, zero, 0
#cmp x1, x2
seteq x0
#cmp x0, #0
je L41
# Compound statement
# Function call
lea x3, str43
j str43_end
str43: .string "0"
str43_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L42
L41:
# Compound statement
# Function call
lea x3, str44
j str44_end
str44: .string "?"
str44_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
L42:
L39:
# Function call
lea x3, str45
j str45_end
str45: .string "
"
str45_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
# Function call
lea x3, str46
j str46_end
str46: .string "All operations completed
"
str46_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
# If statement
lw x1, 0(fp-12)
addi x2, zero, 1
#cmp x1, x2
seteq x0
#cmp x0, #0
je L47
# Compound statement
# Function call
lea x3, str49
j str49_end
str49: .string "SUCCESS: Final modulo result is 1 as expected
"
str49_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
j L48
L47:
# Compound statement
# Function call
lea x3, str50
j str50_end
str50: .string "ERROR: Unexpected modulo result
"
str50_end:
addi sp, sp, -4
    sw x3, 0(sp)
call log_string
add sp, sp, #4
mov x0, x0
L48:
# Return statement
lw x0, 0(fp-12)
add sp, sp, #64
lw fp, 0(sp)
    addi sp, sp, 4
ret
main_end:
add sp, sp, #64
lw fp, 0(sp)
    addi sp, sp, 4
ret


# Program entry point
_start:
call main
ebreak
